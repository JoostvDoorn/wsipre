
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>slide &#8212; wsipre 0.0.1 documentation</title>
    <link rel="stylesheet" href="../_static/better.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  </head><body>
    <header id="pageheader"><h1><a href="../index.html ">
        wsipre 0.0.1 documentation
    </a></h1></header>
  <div class="related top">
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
  <nav id="breadcrumbs">
    <ul>
      <li><a href="../index.html">wsipre 0.0.1 documentation</a></li>
      <li>
        <a href="index.html">Module code</a>
      </li> 
    </ul>
  </nav>
  </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for slide</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Handle annotated whole-slide images (WSI; also known as virtual slides).</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">distutils.version</span> <span class="k">import</span> <span class="n">StrictVersion</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">openslide</span>
<span class="kn">import</span> <span class="nn">cv2</span>

<span class="kn">import</span> <span class="nn">annotation</span> <span class="k">as</span> <span class="nn">reader</span>
<span class="kn">import</span> <span class="nn">tissue</span>


<span class="k">class</span> <span class="nc">_AnnotatedOpenSlide</span><span class="p">(</span><span class="n">openslide</span><span class="o">.</span><span class="n">OpenSlide</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An open *annotated* WSI.</span>

<span class="sd">    Wrapper of `openslide.OpenSlide` to handle annotation polygons together</span>
<span class="sd">    with their corresponding OpenSlide Python WSI instances.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename: str</span>
<span class="sd">        Path to slide file.</span>
<span class="sd">    annotation_filename: str</span>
<span class="sd">        Path to XML annotation file.</span>
<span class="sd">    data_source: str</span>
<span class="sd">        The computational histology challenge releasing the dataset:</span>
<span class="sd">        * &#39;camelyon&#39;: CAMELYON grand challenges in pathology.</span>
<span class="sd">        * &#39;bach&#39;: BACH Grand Challenge on Breast Cancer Histology Images.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    filename: str</span>
<span class="sd">        The WSI file name to read.</span>
<span class="sd">    annotation_filename: str</span>
<span class="sd">        Corresponding XML annotation file.</span>
<span class="sd">    polygons: list of lists of 2-tuples</span>
<span class="sd">        Polygon region annotations.</span>
<span class="sd">    labels: list of str</span>
<span class="sd">        Polygon region annotation labels.</span>
<span class="sd">    label_map: dict {str: int}</span>
<span class="sd">        Correspondence between polygon region annotation labels and integer</span>
<span class="sd">        values used in numpy masks.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">annotation_filename</span><span class="p">,</span> <span class="n">data_source</span><span class="p">):</span>
        <span class="n">openslide</span><span class="o">.</span><span class="n">OpenSlide</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>  <span class="c1"># Useful to name predicted annotations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotation_filename</span> <span class="o">=</span> <span class="n">annotation_filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span> <span class="o">=</span> <span class="n">data_source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotation_filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span> <span class="o">==</span> <span class="s1">&#39;camelyon&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">camelyon_annotations</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">annotation_filename</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;metastases&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                    <span class="c1"># Avoid value 0 (used by default for unlabeled regions)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;metastases&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
                <span class="c1"># CAMELYON16 data</span>
                <span class="k">elif</span> <span class="s1">&#39;_0&#39;</span> <span class="ow">in</span> <span class="n">labels</span> <span class="ow">or</span> <span class="s1">&#39;_1&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;_0&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;_1&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;_2&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Predicted annotations</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;predicted_tumor&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span> <span class="o">==</span> <span class="s1">&#39;bach&#39;</span><span class="p">:</span>
                <span class="c1"># Value 1 is reserved for &#39;normal&#39; tissue annotations</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Benign&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Carcinoma in situ&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                                  <span class="s1">&#39;Invasive carcinoma&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">bach_annotations</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">annotation_filename</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;&quot;data_source&quot; value must be either &quot;camelyon&quot; or &quot;bach&quot;.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;&quot;data_source&quot; is only used if an &#39;</span> <span class="o">+</span>
                              <span class="s1">&#39;&quot;annotation_filename&quot; is provided.&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="Slide"><a class="viewcode-back" href="../slide.html#slide.Slide">[docs]</a><span class="k">class</span> <span class="nc">Slide</span><span class="p">(</span><span class="n">_AnnotatedOpenSlide</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An open WSI, with or without annotations.</span>

<span class="sd">    Added functionality to OpenSlide WSI instances, optionally with</span>
<span class="sd">    annotations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename: str</span>
<span class="sd">        Path to slide file. Namesake argument to `openslide.OpenSlide` and</span>
<span class="sd">        `AnnotatedOpenSlide`.</span>
<span class="sd">    annotation_filename: str</span>
<span class="sd">        Path to XML annotation file. Namesake argument to `AnnotatedOpenSlide`.</span>
<span class="sd">    data_source: str</span>
<span class="sd">        The computational histology challenge releasing the dataset. Namesake</span>
<span class="sd">        argument to `AnnotatedOpenSlide`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    tissue_mask: Numpy 2D array</span>
<span class="sd">        Tissue RoI ``annotation``.</span>
<span class="sd">    tissue_label_map: dict {str: int}</span>
<span class="sd">        Correspondence between polygon region annotation labels and integer</span>
<span class="sd">        values used in numpy masks.</span>
<span class="sd">    downsampling_factor: float</span>
<span class="sd">        The scaling factor relative to level 0 dimensions.</span>
<span class="sd">    downsampled_slide: PIL image</span>
<span class="sd">        The scaled down slide generated when running the tissue detector.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from wsipre import slide</span>
<span class="sd">    &gt;&gt;&gt; wsi = slide.Slide(&#39;tumor_001.tif&#39;, &#39;tumor_001.xml&#39;, &#39;camelyon&#39;)</span>
<span class="sd">    &gt;&gt;&gt; wsi.label_map</span>
<span class="sd">    {&#39;_0&#39;: 2, &#39;_1&#39;: 2, &#39;_2&#39;: 1}</span>
<span class="sd">    &gt;&gt;&gt; wsi.level_count</span>
<span class="sd">    10</span>
<span class="sd">    &gt;&gt;&gt; len(wsi.polygons)</span>
<span class="sd">    2</span>

<span class="sd">    &gt;&gt;&gt; thumbnail, mask, dwnspl_factor = wsi.get_thumbnail_with_annotation(</span>
<span class="sd">    ...     size=(3000, 3000), polygon_type=&#39;line&#39;, line_thickness=5)</span>

<span class="sd">    &gt;&gt;&gt; slide_region = wsi.read_region_with_annotation(</span>
<span class="sd">    ...     location=(65000, 110000), level=4, size=(1000, 1000))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">annotation_filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_source</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tissue_mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tissue_label_map</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">downsampling_factor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">downsampled_slide</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># OpenSlide version &lt; 3.4.1 lacks support for some recent file formats</span>
        <span class="n">version</span> <span class="o">=</span> <span class="n">openslide</span><span class="o">.</span><span class="n">__library_version__</span>
        <span class="k">if</span> <span class="n">StrictVersion</span><span class="p">(</span><span class="n">version</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">StrictVersion</span><span class="p">(</span><span class="s1">&#39;3.4.1&#39;</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="n">f</span><span class="s1">&#39;OpenSlide version </span><span class="si">{version}</span><span class="s1"> lacks support for some &#39;</span> <span class="o">+</span>
                <span class="s1">&#39;whole-slide image file formats. It is highly recommended &#39;</span> <span class="o">+</span>
                <span class="s1">&#39;to update to a more recent version.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">annotation_filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data_source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s1">&#39;&quot;data_source&quot; is not used (no annotation was provided).&#39;</span><span class="p">)</span>
            <span class="n">openslide</span><span class="o">.</span><span class="n">OpenSlide</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_AnnotatedOpenSlide</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">annotation_filename</span><span class="p">,</span> <span class="n">data_source</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_draw_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">polygons</span><span class="p">,</span> <span class="n">polygon_type</span><span class="p">,</span>
                       <span class="n">line_thickness</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert polygon vertex coordinates to polygon drawing.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">poly</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">polygons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">polygon_type</span> <span class="o">==</span> <span class="s1">&#39;line&#39;</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">polylines</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">poly</span><span class="p">],</span> <span class="kc">True</span><span class="p">,</span>
                                     <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">label</span><span class="p">]),</span>
                                     <span class="n">line_thickness</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">polygon_type</span> <span class="o">==</span> <span class="s1">&#39;area&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">line_thickness</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;&quot;line_thickness&quot; is only used if &#39;</span> <span class="o">+</span>
                                  <span class="s1">&#39;&quot;polygon_type&quot; is &quot;line&quot;.&#39;</span><span class="p">)</span>

                <span class="n">mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">fillPoly</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">poly</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">label</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Accepted &quot;polygon_type&quot; values are &quot;line&quot; or &quot;area&quot;.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">_draw_tissue_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">polygons</span><span class="p">,</span> <span class="n">polygon_type</span><span class="p">,</span>
                              <span class="n">line_thickness</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert tissue polygon vertex coordinates to polygon drawing.&quot;&quot;&quot;</span>
        <span class="n">tissue_label</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polygons</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">polygon_type</span> <span class="o">==</span> <span class="s1">&#39;line&#39;</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">polylines</span><span class="p">(</span>
                    <span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">poly</span><span class="p">],</span> <span class="kc">True</span><span class="p">,</span> <span class="n">tissue_label</span><span class="p">,</span> <span class="n">line_thickness</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">polygon_type</span> <span class="o">==</span> <span class="s1">&#39;area&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">line_thickness</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;&quot;line_thickness&quot; is only used if &#39;</span> <span class="o">+</span>
                                  <span class="s1">&#39;&quot;polygon_type&quot; is &quot;line&quot;.&#39;</span><span class="p">)</span>

                <span class="n">mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">fillPoly</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">poly</span><span class="p">],</span> <span class="n">tissue_label</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Accepted &quot;polygon_type&quot; values are &quot;line&quot; or &quot;area&quot;.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">_update_label_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotation_mask</span><span class="p">):</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">annotation_mask</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">label</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                          <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Slide.get_thumbnail_with_annotation"><a class="viewcode-back" href="../slide.html#slide.Slide.get_thumbnail_with_annotation">[docs]</a>    <span class="k">def</span> <span class="nf">get_thumbnail_with_annotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">polygon_type</span><span class="o">=</span><span class="s1">&#39;area&#39;</span><span class="p">,</span>
                                      <span class="n">line_thickness</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert *annotated* WSI to a scaled-down thumbnail.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size: 2-tuple</span>
<span class="sd">            Maximum size of compressed image thumbnail as (width, height).</span>
<span class="sd">        polygon_type: str</span>
<span class="sd">            Type of polygon drawing:</span>
<span class="sd">            * &#39;line&#39;</span>
<span class="sd">            * &#39;area&#39;</span>
<span class="sd">        line_thickness: int</span>
<span class="sd">            Polygon edge line thickness. Required if ``polygon_type`` is</span>
<span class="sd">            ``line``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Scaled down slide (as PIL RGBA image) and annotation mask (as numpy 2D</span>
<span class="sd">        array), plus the scaling factor.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;No annotation is available. Please load an annotation &#39;</span> <span class="o">+</span>
                    <span class="s1">&#39;or consider using &quot;get_thumbnail&quot; instead.&#39;</span><span class="p">)</span>

        <span class="n">thumb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_thumbnail</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="n">width_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">height_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">downsampling_factor</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">width_factor</span><span class="p">,</span> <span class="n">height_factor</span><span class="p">)</span>

        <span class="n">polygons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">])</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="n">polygons</span> <span class="o">/</span> <span class="n">downsampling_factor</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="p">[</span><span class="n">poly</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polygons</span><span class="p">]</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">thumb</span><span class="o">.</span><span class="n">size</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Reverse width and height</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_polygons</span><span class="p">(</span>
            <span class="n">mask</span><span class="p">,</span> <span class="n">polygons</span><span class="p">,</span> <span class="n">polygon_type</span><span class="p">,</span> <span class="n">line_thickness</span><span class="p">)</span>

        <span class="c1"># Drop unused labels from label_map</span>
        <span class="c1"># self._update_label_map(mask)</span>

        <span class="k">return</span> <span class="n">thumb</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">downsampling_factor</span></div>

<div class="viewcode-block" id="Slide.read_region_with_annotation"><a class="viewcode-back" href="../slide.html#slide.Slide.read_region_with_annotation">[docs]</a>    <span class="k">def</span> <span class="nf">read_region_with_annotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
                                    <span class="n">polygon_type</span><span class="o">=</span><span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="n">line_thickness</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Crop a smaller region from an *annotated* WSI.</span>

<span class="sd">        Get a defined region from a WSI, together with its annotation mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        location: 2-tuple</span>
<span class="sd">            X and y coordinates of the top left pixel. Namesake argument to</span>
<span class="sd">            OpenSlide&#39;s &quot;read_region&quot; function.</span>
<span class="sd">        level: int</span>
<span class="sd">            Slide level. Namesake argument to OpenSlide&#39;s &quot;read_region&quot;</span>
<span class="sd">            function.</span>
<span class="sd">        size: 2-tuple</span>
<span class="sd">            Crop size (width, height). Namesake argument to OpenSlide&#39;s</span>
<span class="sd">            &quot;read_region&quot; function.</span>
<span class="sd">        polygon_type: str</span>
<span class="sd">            Type of polygon drawing:</span>
<span class="sd">            * &#39;line&#39;</span>
<span class="sd">            * &#39;area&#39;</span>
<span class="sd">        line_thickness: int</span>
<span class="sd">            Polygon edge line thickness. Required if &#39;polygon_type&#39; is &#39;line&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Image region (as PIL RGBA image) and the annotation mask (as numpy 2d</span>
<span class="sd">        array).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;No annotation is available. Please load an annotation &#39;</span> <span class="o">+</span>
                    <span class="s1">&#39;or consider using &quot;read_region&quot; instead.&#39;</span><span class="p">)</span>
        <span class="n">downsampling_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">level_downsamples</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
        <span class="n">slide_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_region</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

        <span class="n">polygons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">])</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="n">polygons</span> <span class="o">/</span> <span class="n">downsampling_factor</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="p">[</span><span class="n">poly</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polygons</span><span class="p">]</span>

        <span class="n">location</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">coord</span> <span class="o">/</span> <span class="n">downsampling_factor</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">location</span><span class="p">)</span>

        <span class="c1"># Convert polygon coordinates to patch coordinates</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="p">[</span><span class="n">poly</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polygons</span><span class="p">]</span>

        <span class="n">mask_region</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">mask_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_polygons</span><span class="p">(</span>
           <span class="n">mask_region</span><span class="p">,</span> <span class="n">polygons</span><span class="p">,</span> <span class="n">polygon_type</span><span class="p">,</span> <span class="n">line_thickness</span><span class="p">)</span>

        <span class="c1"># Drop unused labels from label_map</span>
        <span class="c1"># self._update_label_map(mask_region)</span>

        <span class="k">return</span> <span class="n">slide_region</span><span class="p">,</span> <span class="n">mask_region</span></div>

<div class="viewcode-block" id="Slide.get_tissue_mask"><a class="viewcode-back" href="../slide.html#slide.Slide.get_tissue_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_tissue_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">downsampling_factor</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">polygon_type</span><span class="o">=</span><span class="s1">&#39;area&#39;</span><span class="p">,</span>
                        <span class="n">line_thickness</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate tissue region annotation.</span>

<span class="sd">        Make a binary mask annotating tissue regions of interest (RoI) on the</span>
<span class="sd">        WSI using an automatic threshold-based segmentation method inspired by</span>
<span class="sd">        the one used by Wang *et al.* [1]_. Briefly, the method consists on the</span>
<span class="sd">        following steps, starting from a WSI:</span>
<span class="sd">            * Select downsampling level (typically a factor of 64)</span>
<span class="sd">            * Transfer from the RGB to the HSV color space</span>
<span class="sd">            * Determine optimal threshold value in the saturation channel using</span>
<span class="sd">              the Otsu algorithm [2]_</span>
<span class="sd">            * Threshold image to generate a binary mask</span>
<span class="sd">            * Fill in small holes and remove small objects</span>

<span class="sd">        .. [1] Dayong Wang, Aditya Khosla, Rishab Gargeya, Humayun Irshad,</span>
<span class="sd">           Andrew H. Beck, &quot;Deep Learning for Identifying Metastatic Breast</span>
<span class="sd">           Cancer&quot;, arXiv:1606.05718.</span>

<span class="sd">        .. [2] Nobuyuki Otsu, &quot;A Threshold Selection Method from Gray-level</span>
<span class="sd">           Histograms&quot;, IEEE Trans Syst Man Cybern., 9(1):62–66, 1979.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        downsampling_factor: int</span>
<span class="sd">            The desired factor to downsample the image by, since full WSIs will</span>
<span class="sd">            not fit in memory. The image&#39;s closest level downsample is found</span>
<span class="sd">            and used.</span>
<span class="sd">        polygon_type: str</span>
<span class="sd">            Type of polygon drawing:</span>
<span class="sd">            * &#39;line&#39;</span>
<span class="sd">            * &#39;area&#39;</span>
<span class="sd">        line_thickness: int</span>
<span class="sd">            Polygon edge line thickness. Required if ``polygon_type`` is</span>
<span class="sd">            ``line``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Binary mask as numpy 2D array, RGB slide image (in the used</span>
<span class="sd">        downsampling level, to allow visualization) and downsampling factor.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">mask_contours</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">downsampled_slide</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">downsampling_factor</span><span class="p">)</span> <span class="o">=</span> <span class="n">tissue</span><span class="o">.</span><span class="n">detect_tissue</span><span class="p">(</span>
             <span class="bp">self</span><span class="p">,</span> <span class="n">downsampling_factor</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">downsampled_slide</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tissue_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_tissue_polygons</span><span class="p">(</span>
           <span class="n">mask</span><span class="p">,</span> <span class="n">mask_contours</span><span class="p">,</span> <span class="n">polygon_type</span><span class="p">,</span> <span class="n">line_thickness</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tissue_label_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;background&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;tissue&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">_get_random_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">annotation_mask</span><span class="p">,</span>
                                <span class="n">mask_downsampling_factor</span><span class="p">,</span> <span class="n">target_class</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get region (patch) coordinates at random.&quot;&quot;&quot;</span>
        <span class="c1"># Select coordinates matching target class at random</span>
        <span class="n">pixels_in_roi</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">annotation_mask</span> <span class="o">==</span> <span class="n">target_class</span><span class="p">)))</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">pixels_in_roi</span><span class="p">)</span>

        <span class="c1"># Scale coordinates up to level-0 dimensions</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">mask_downsampling_factor</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="p">]</span>

        <span class="c1"># OpenSlide Python&#39;s read_region takes top left corner position, which</span>
        <span class="c1"># effectively excludes tissue above and to the left of annotations</span>
        <span class="c1"># Fix it by offsetting coordinates: convert to center pixel position</span>
        <span class="c1"># (subtract half of patch size from x and y coordinates)</span>
        <span class="n">half_size</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">level_downsamples</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">size</span><span class="p">]</span>
        <span class="n">row_location</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">half_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">col_location</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">half_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Make sure coordinates are still within slide margins</span>
        <span class="n">cols_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rows_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">row_location</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">row_location</span><span class="p">,</span> <span class="n">rows_edge</span><span class="p">))</span>
        <span class="n">col_location</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">col_location</span><span class="p">,</span> <span class="n">cols_edge</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">col_location</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">row_location</span><span class="p">)</span>  <span class="c1"># OpenSlide: width, height</span>

    <span class="k">def</span> <span class="nf">_max_repeated_pixel_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute ratio of count of most common pixel value to total count.&quot;&quot;&quot;</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="o">/</span> <span class="n">image</span><span class="o">.</span><span class="n">size</span>

<div class="viewcode-block" id="Slide.read_random_tissue_patch"><a class="viewcode-back" href="../slide.html#slide.Slide.read_random_tissue_patch">[docs]</a>    <span class="k">def</span> <span class="nf">read_random_tissue_patch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Crop random patch from detected tissue on WSI.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level: int</span>
<span class="sd">            Slide level. Namesake argument to OpenSlide&#39;s &quot;read_region&quot;</span>
<span class="sd">            function.</span>
<span class="sd">        size: 2-tuple</span>
<span class="sd">            Crop size (width, height). Namesake argument to OpenSlide&#39;s</span>
<span class="sd">            &quot;read_region&quot; function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Image region or patch (as PIL RGBA image).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tissue_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_tissue_mask</span><span class="p">()</span>

        <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_coordinates</span><span class="p">(</span>
            <span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tissue_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsampling_factor</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">patch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_region</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

        <span class="c1"># Avoid false positive regions where a large proportion of pixels is</span>
        <span class="c1"># exactly the same</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_repeated_pixel_ratio</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_coordinates</span><span class="p">(</span>
                <span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tissue_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsampling_factor</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
            <span class="n">patch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_region</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">patch</span></div>

    <span class="k">def</span> <span class="nf">_get_area_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">target_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute ratio of pixels labeled as &#39;target_class&#39; to all pixels.&quot;&quot;&quot;</span>
        <span class="n">class_pixels</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">target_class</span><span class="p">)]</span><span class="o">.</span><span class="n">size</span>

        <span class="k">return</span> <span class="n">class_pixels</span> <span class="o">/</span> <span class="n">mask</span><span class="o">.</span><span class="n">size</span>

    <span class="k">def</span> <span class="nf">_pick_random_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">target_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pick random patch to crop from WSI.&quot;&quot;&quot;</span>
        <span class="c1"># Get thumbnail and select coordinates at random</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">downsampling_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_thumbnail_with_annotation</span><span class="p">(</span>
             <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">5000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">),</span> <span class="n">polygon_type</span><span class="o">=</span><span class="s1">&#39;area&#39;</span><span class="p">)</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_coordinates</span><span class="p">(</span>
            <span class="n">level</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">downsampling_factor</span><span class="p">,</span> <span class="n">target_class</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

        <span class="c1"># Get ratio (polygon type must be &#39;area&#39;)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_region_with_annotation</span><span class="p">(</span>
            <span class="n">coordinates</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">polygon_type</span><span class="o">=</span><span class="s1">&#39;area&#39;</span><span class="p">)</span>
        <span class="n">area_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_area_ratio</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">target_class</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">area_ratio</span>

<div class="viewcode-block" id="Slide.read_random_patch"><a class="viewcode-back" href="../slide.html#slide.Slide.read_random_patch">[docs]</a>    <span class="k">def</span> <span class="nf">read_random_patch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">target_class</span><span class="p">,</span>
                          <span class="n">min_class_area_ratio</span><span class="p">,</span> <span class="n">polygon_type</span><span class="o">=</span><span class="s1">&#39;area&#39;</span><span class="p">,</span>
                          <span class="n">line_thickness</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Crop random patch from WSI.</span>

<span class="sd">        Select random location within target class according to provided</span>
<span class="sd">        annotation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level: int</span>
<span class="sd">            Slide level. Namesake argument to OpenSlide&#39;s &quot;read_region&quot;</span>
<span class="sd">            function.</span>
<span class="sd">        size: 2-tuple</span>
<span class="sd">            Crop size (width, height). Namesake argument to OpenSlide&#39;s</span>
<span class="sd">            &quot;read_region&quot; function.</span>
<span class="sd">        target_class: int</span>
<span class="sd">            The class annotation of the central pixel of the patch.</span>
<span class="sd">            function.</span>
<span class="sd">        min_class_area_ratio: float (0, 20]</span>
<span class="sd">            Minimum ratio of target class pixels to total pixels.</span>
<span class="sd">        polygon_type: str</span>
<span class="sd">            Type of polygon drawing:</span>
<span class="sd">            * &#39;line&#39;</span>
<span class="sd">            * &#39;area&#39;</span>
<span class="sd">        line_thickness: int</span>
<span class="sd">            Polygon edge line thickness. Required if ``polygon_type`` is</span>
<span class="sd">            ``line``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Image region or patch (as PIL RGBA image).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">min_class_area_ratio</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;&quot;min_class_area_ratio&quot; must be in the interval (0, 1].&#39;</span><span class="p">)</span>

        <span class="n">coordinates</span><span class="p">,</span> <span class="n">area_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pick_random_coordinates</span><span class="p">(</span>
            <span class="n">level</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">target_class</span><span class="p">)</span>

        <span class="c1"># When the slide level is high, the following while loop may be</span>
        <span class="c1"># infinite, since the tumor area will never be high enough.</span>
        <span class="c1"># Try to sample a few times and throw error if not successful</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">area_ratio</span> <span class="o">&lt;</span> <span class="n">min_class_area_ratio</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">coordinates</span><span class="p">,</span> <span class="n">area_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pick_random_coordinates</span><span class="p">(</span>
                <span class="n">level</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">target_class</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Cannot seem to find patch with a minimum of &#39;</span> <span class="o">+</span>
                    <span class="n">f</span><span class="s1">&#39;{min_class_area_ratio * 100}</span><span class="si">% o</span><span class="s1">f class </span><span class="si">{target_class}</span><span class="s1">.&#39;</span> <span class="o">+</span>
                    <span class="s1">&#39; The chosen slide level may be too high.&#39;</span><span class="p">)</span>

        <span class="c1"># Get actual data (chosen polygon type)</span>
        <span class="n">patch</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_region_with_annotation</span><span class="p">(</span>
            <span class="n">coordinates</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">polygon_type</span><span class="p">,</span> <span class="n">line_thickness</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">patch</span><span class="p">,</span> <span class="n">mask</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<form class="search" action="../search.html" method="get">
  <input type="text" name="q"
   placeholder="type to search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="related bottom">
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
  <nav id="breadcrumbs">
    <ul>
      <li><a href="../index.html">wsipre 0.0.1 documentation</a></li>
      <li>
        <a href="index.html">Module code</a>
      </li> 
    </ul>
  </nav>
  </div>
  <footer id="pagefooter">&copy; 2018, Luis A. Vale Silva.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a>
      1.8.2
        with the <a href="http://github.com/irskep/sphinx-better-theme">
          better</a> theme.

  </footer>

  
  </body>
</html>